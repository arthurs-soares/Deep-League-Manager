// handlers/panel/warTicketActions.js
const { EmbedBuilder, ButtonStyle, ModalBuilder, TextInputBuilder, TextInputStyle, ActionRowBuilder, ChannelType, PermissionFlagsBits } = require('discord.js');
// Importa√ß√µes DIRETAS dos m√≥dulos necess√°rios
const { loadGuildByName, saveGuildData } = require('../db/guildDb');
const { saveWarTicket, loadWarTicketByThreadId, deleteWarTicket } = require('../db/warDb'); 
const { sendLogMessage } = require('../utils/logManager');                              // <-- Caminho corrigido
const { resolveDisplayColor } = require('../utils/constants');                      // <-- Caminho corrigido
const { loadUserProfile, saveUserProfile } = require('../db/userProfileDb'); // <-- ADICIONE ESTA LINHA
const { loadTeamByName, saveTeamData } = require('../db/teamDb');

// Importar as fun√ß√µes de cria√ß√£o de bot√µes aqui. Este m√≥dulo S√ì DEVE IMPORTAR FUN√á√ïES PARA CONSTRUIR BOT√ïES, NUNCA HANDLERS DE MODAIS.
const { createWarCurrentButtons } = require('./warTicketButtons'); 

const MAX_ROUNDS = 3; 
const ROUNDS_TO_WIN = 2; 


async function saveEntityScore(entityName, entityType, scoreChange) {
    let entityDB;
    if (entityType === 'guild') {
        entityDB = await loadGuildByName(entityName);
        if (entityDB) {
            entityDB.score.wins += scoreChange.wins;
            entityDB.score.losses += scoreChange.losses;
            await saveGuildData(entityDB);
        }
    } else if (entityType === 'team') {
        entityDB = await loadTeamByName(entityName);
        if (entityDB) {
            entityDB.score.wins += scoreChange.wins;
            entityDB.score.losses += scoreChange.losses;
            await saveTeamData(entityDB);
        }
    }
}

async function updatePartyMembersScore(entityData, entityType, result) {
    if (!entityData) { // Simplificado para apenas verificar se entityData existe
        console.warn(`[Score Pessoal] Dados da entidade inv√°lidos ou nulos recebidos.`);
        return;
    }

    const memberIds = new Set();

    if (entityType === 'guild') {
        // Usa entityData, que √© o objeto da guilda
        if (entityData.leader?.id) memberIds.add(entityData.leader.id);
        if (entityData.coLeader?.id) memberIds.add(entityData.coLeader.id);
        (entityData.mainRoster || []).forEach(member => memberIds.add(member.id));
        (entityData.subRoster || []).forEach(member => memberIds.add(member.id));
    } else if (entityType === 'team') {
        // Usa entityData, que √© o objeto do time
        if (entityData.leader?.id) memberIds.add(entityData.leader.id);
        (entityData.roster || []).forEach(member => memberIds.add(member.id));
    }

    if (memberIds.size === 0) {
        console.warn(`[Score Pessoal] Nenhum membro encontrado para a entidade ${entityData.name} (${entityType}) para atualizar scores.`);
        return;
    }

    for (const userId of memberIds) {
        try {
            const userProfile = await loadUserProfile(userId);
            if (result === 'win') {
                userProfile.personalScore.wins = (userProfile.personalScore.wins || 0) + 1;
            } else {
                userProfile.personalScore.losses = (userProfile.personalScore.losses || 0) + 1;
            }
            await saveUserProfile(userProfile);
        } catch (error) {
            console.error(`[Score Pessoal] Falha ao atualizar o perfil do usu√°rio ${userId}:`, error);
        }
    }
    console.log(`[Score Pessoal] Scores de '${result}' atualizados para ${memberIds.size} membros de ${entityData.name} (${entityType}).`);
}

/**
 * Fun√ß√£o principal que orquestra a atualiza√ß√£o dos scores ap√≥s uma war.
 * Renomeada de updatePersonalScores para uma maior clareza.
 * @param {string} winningGuildName - O NOME da guilda vencedora.
 * @param {string} losingGuildName - O NOME da guilda perdedora.
 */
async function processWarResultForPersonalScores(winningEntity, losingEntity) {
    try {
        let winningEntityDB, losingEntityDB;

        // Carrega o documento completo da entidade vencedora
        if (winningEntity.type === 'guild') {
            winningEntityDB = await loadGuildByName(winningEntity.name);
        } else if (winningEntity.type === 'team') {
            winningEntityDB = await loadTeamByName(winningEntity.name);
        }

        // Carrega o documento completo da entidade perdedora
        if (losingEntity.type === 'guild') {
            losingEntityDB = await loadGuildByName(losingEntity.name);
        } else if (losingEntity.type === 'team') {
            losingEntityDB = await loadTeamByName(losingEntity.name);
        }

        // Chama updatePartyMembersScore com os dados completos do DB
        if (winningEntityDB) {
            await updatePartyMembersScore(winningEntityDB, winningEntity.type, 'win');
        } else {
            console.error(`[Score Pessoal] Entidade vencedora "${winningEntity.name}" n√£o encontrada no DB.`);
        }

        if (losingEntityDB) {
            await updatePartyMembersScore(losingEntityDB, losingEntity.type, 'loss');
        } else {
            console.error(`[Score Pessoal] Entidade perdedora "${losingEntity.name}" n√£o encontrada no DB.`);
        }
    } catch (error) {
        console.error('‚ùå Erro fatal dentro de processWarResultForPersonalScores:', error);
    }
}

async function restrictThreadAccessOnCompletion(interaction, client, globalConfig, warData) {
    const thread = interaction.channel;
    if (!thread || !client || !globalConfig || !warData) {
        console.error('[RESTRICT THREAD] Par√¢metros ausentes para restrictThreadAccessOnCompletion.');
        return;
    }

    try {
        // 1. Nega SendMessages para @everyone na thread
        await thread.permissionOverwrites.edit(thread.guild.roles.everyone, {
            SendMessages: false,
            SendMessagesInThreads: false,
        });

        // Garante que o bot pode enviar mensagens
        await thread.permissionOverwrites.edit(client.user.id, {
            SendMessages: true,
            SendMessagesInThreads: true,
        });
        console.log(`[RESTRICT THREAD] Negado SendMessages para @everyone na thread ${thread.id}`);

        // 2. Garante que roles espec√≠ficas (moderadores, operadores de score) PODEM enviar mensagens
        const rolesToAllowSend = new Set();
        if (globalConfig.moderatorRoles) {
            globalConfig.moderatorRoles.forEach(id => rolesToAllowSend.add(id));
        }
        if (globalConfig.scoreOperatorRoles) {
            globalConfig.scoreOperatorRoles.forEach(id => rolesToAllowSend.add(id));
        }

        for (const roleId of rolesToAllowSend) {
            const role = await thread.guild.roles.fetch(roleId).catch(() => null);
            if (role) {
                await thread.permissionOverwrites.edit(role.id, { SendMessages: true, SendMessagesInThreads: true });
                console.log(`[RESTRICT THREAD] Garantido SendMessages para o cargo ${role.name} na thread ${thread.id}`);
            }
        }

        // 3. Garante que usu√°rios espec√≠ficos (solicitante, l√≠deres, co-l√≠deres, bot) PODEM enviar mensagens
        const usersToEnsureSend = new Set([
            client.user.id, warData.requesterId,
            warData.yourGuild.leader?.id, warData.yourGuild.coLeader?.id,
            warData.enemyGuild.leader?.id, warData.enemyGuild.coLeader?.id
        ].filter(Boolean)); // .filter(Boolean) remove undefined/null IDs

        for (const userId of usersToEnsureSend) {
            const member = await thread.guild.members.fetch(userId).catch(() => null);
            if (member) {
                await thread.permissionOverwrites.edit(member.id, { SendMessages: true, SendMessagesInThreads: true });
            }
        }
        if (thread.send) { // Verifica se a fun√ß√£o send existe
            await thread.send('üîí As permiss√µes deste t√≥pico foram ajustadas. O t√≥pico ser√° arquivado em breve.').catch(console.error);
        }

        if (thread.archivable && !thread.locked) {
            await thread.setArchived(true, 'War conclu√≠da/Dodge. T√≥pico arquivado.').catch(console.error);
            console.log(`[RESTRICT THREAD] Thread ${thread.id} arquivada.`);
        }
    } catch (error) {
        console.error(`[RESTRICT THREAD] Erro em restrictThreadAccessOnCompletion para ${thread.id}:`, error);
        if (thread.send) {
            await thread.send(`‚ö†Ô∏è Ocorreu um erro ao tentar ajustar as permiss√µes e arquivar este t√≥pico: ${error.message}`).catch(() => {});
        }
    }
}

/**
 * Lida com o clique no bot√£o "Aceitar War".
 * @param {ButtonInteraction} interaction - A intera√ß√£o do bot√£o.
 * @param {Client} client - A inst√¢ncia do bot.
 * @param {Object} globalConfig - A configura√ß√£o global do bot.
 */
async function handleWarAcceptButton(interaction, client, globalConfig) {
    await interaction.deferUpdate();

    const threadId = interaction.channel.id;
    const warData = await loadWarTicketByThreadId(threadId);

    if (!warData || warData.status !== 'Aguardando Aceita√ß√£o') {
        return interaction.followUp({ content: '‚ùå Esta war n√£o est√° aguardando aceita√ß√£o ou j√° foi iniciada/conclu√≠da.', ephemeral: true });
    }

    // --- L√≥gica de permiss√£o para ACEITAR WAR (ROBUSTA E CORRIGIDA) ---

    // 1. Recarrega o membro que interagiu para garantir que os cargos est√£o atualizados
    const member = await interaction.guild.members.fetch(interaction.user.id);

    // 2. Verifica se o membro √© um moderador geral ou administrador do servidor
    const isModerator = member.permissions.has('Administrator') ||
                        (globalConfig.moderatorRoles || []).some(roleId => member.roles.cache.has(roleId));

    // 3. Verifica se o membro √© um operador de score
    const isScoreOperator = (globalConfig.scoreOperatorRoles || []).some(roleId => member.roles.cache.has(roleId));
    
    // 4. Se for staff, j√° tem permiss√£o.
    let hasPermission = isModerator || isScoreOperator;

    // 5. Se ainda n√£o tem permiss√£o, verifica se √© l√≠der/co-l√≠der da entidade inimiga
    if (!hasPermission) {
        const enemyEntity = warData.enemyEntity;
        let enemyEntityData;

        // Carrega a entidade correta (guilda ou time) do banco de dados
        if (enemyEntity.type === 'guild') {
            enemyEntityData = await loadGuildByName(enemyEntity.name);
        } else if (enemyEntity.type === 'team') {
            enemyEntityData = await loadTeamByName(enemyEntity.name);
        }
        
        // Verifica se a entidade existe e se o usu√°rio tem cargo de lideran√ßa nela
        if (enemyEntityData) {
            if (enemyEntityData.leader?.id === interaction.user.id) {
                hasPermission = true;
            }
            // Se for guilda, verifica tamb√©m se √© co-l√≠der
            if (enemyEntity.type === 'guild' && enemyEntityData.coLeader?.id === interaction.user.id) {
                hasPermission = true;
            }
        }
    }

    // 6. Verifica√ß√£o final
    if (!hasPermission) {
        return interaction.followUp({
            content: `‚ùå Apenas o l√≠der/co-l√≠der da entidade inimiga, moderadores ou operadores de score podem aceitar a war.`,
            ephemeral: true
        });
    }

    // --- O resto da l√≥gica da fun√ß√£o ---
    warData.status = 'Aceita';
    warData.currentRound = 1;

    await saveWarTicket(warData);

let warEmbed = new EmbedBuilder(interaction.message.embeds[0].toJSON());
    warEmbed.fields = warEmbed.data.fields || [];

    const statusFieldIndex = warEmbed.fields.findIndex(field => field.name === 'Status');
    const newStatusValue = `‚úÖ War Aceita - Round ${warData.currentRound}`;
    if (statusFieldIndex !== -1) {
        warEmbed.spliceFields(statusFieldIndex, 1, { name: 'Status', value: newStatusValue, inline: false });
    } else {
        warEmbed.addFields({ name: 'Status', value: newStatusValue, inline: false });
    }
    warEmbed.setColor('#3498DB');

    // A fun√ß√£o createWarCurrentButtons j√° deve estar usando a nova estrutura warData
    const components = createWarCurrentButtons(warData);
    await interaction.message.edit({ embeds: [warEmbed], components: components });
    await saveWarTicket(warData);
    await interaction.message.edit({ embeds: [warEmbed], components: components });
    await interaction.channel.send(`üéâ A War/Glad entre **${warData.yourEntity.name}** e **${warData.enemyEntity.name}** foi **ACEITA**! Boa sorte!`);

    await sendLogMessage(
        client, globalConfig, interaction,
        'War Aceita',
        `A War/Glad entre **${warData.yourEntity.name}** e **${warData.enemyEntity.name}** foi aceita.`,
        [
            { name: 'Status Atual', value: warData.status, inline: true },
            { name: 'Thread da War', value: interaction.channel.url, inline: true },
        ]
    );
}


/**
 * Lida com o clique no bot√£o "Solicitar Dodge". Abre um modal para o operador selecionar a guilda que deu dodge.
 * @param {ButtonInteraction} interaction - A intera√ß√£o do bot√£o.
 * @param {Client} client - A inst√¢ncia do bot.
 * @param {Object} globalConfig - A configura√ß√£o global do bot.
 */
async function handleWarRequestDodgeButton(interaction, client, globalConfig) {
    const threadId = interaction.channel.id;
    const warData = await loadWarTicketByThreadId(threadId);

    console.log(`[DEBUG DODGE] warData carregado para thread ${threadId}:`, warData);
    console.log(`[DEBUG DODGE] Status da warData: ${warData ? warData.status : 'undefined'}`);

    if (!warData || warData.status === 'Conclu√≠da' || warData.status === 'WO' || warData.status === 'Dodge') {
        console.log(`[DEBUG DODGE] Condi√ß√£o de dodge FALHOU: warData √© ${warData ? 'v√°lido' : 'nulo/indefinido'} ou status inv√°lido (status atual: ${warData ? warData.status : 'N/A'})`);
        return interaction.reply({ content: '‚ùå Esta war j√° foi conclu√≠da ou n√£o pode ser declarada Dodge.', ephemeral: true });
    }
    console.log(`[DEBUG DODGE] Condi√ß√£o de dodge PASSOU.`);


    // L√≥gica de permiss√£o para SOLICITAR DODGE
    const isModerator = (globalConfig.moderatorRoles || []).some(roleId => interaction.member.roles.cache.has(roleId));
    const isScoreOperator = (globalConfig.scoreOperatorRoles || []).some(roleId => interaction.member.roles.cache.has(roleId));

    if (!isModerator && !isScoreOperator) {
        console.log(`[DEBUG DODGE] Falha de permiss√£o para ${interaction.user.tag}.`);
        return interaction.reply({ 
            content: '‚ùå Apenas moderadores ou operadores de score podem solicitar/declarar Dodge.', 
            ephemeral: true 
        });
    }
    console.log(`[DEBUG DODGE] Permiss√µes VERIFICADAS para ${interaction.user.tag}.`);


    const modal = new ModalBuilder()
        .setCustomId(`modal_war_dodge_select_guild_${threadId}`) 
        .setTitle('Declarar Dodge');

    const dodgingGuildInput = new TextInputBuilder()
        .setCustomId('dodging_guild_name')
        .setLabel('Nome da Guilda que Deu Dodge (EXATO)')
        .setStyle(TextInputStyle.Short)
        .setPlaceholder('Ex: Guilda Que Fugiu')
        .setRequired(true);

    modal.addComponents(new ActionRowBuilder().addComponents(dodgingGuildInput));

    await interaction.showModal(modal);
    console.log(`[DEBUG DODGE] Modal de dodge exibido.`);
}

/**
 * Lida com a submiss√£o do modal de sele√ß√£o de guilda para Dodge.
 * Executa a l√≥gica de Dodge.
 * @param {ModalSubmitInteraction} interaction - A intera√ß√£o de submiss√£o do modal.
 * @param {Client} client - A inst√¢ncia do bot.
 * @param {Object} globalConfig - A configura√ß√£o global do bot.
 */
async function handleWarDodgeSelectGuildSubmit(interaction, client, globalConfig) {
    await interaction.deferReply({ ephemeral: true });

    const threadId = interaction.channel.id;
    const warData = await loadWarTicketByThreadId(threadId);

    console.log(`[DEBUG DODGE SUBMIT] warData carregado para thread ${threadId}:`, warData);
    console.log(`[DEBUG DODGE SUBMIT] Status da warData: ${warData ? warData.status : 'undefined'}`);

    if (!warData || warData.status === 'Conclu√≠da' || warData.status === 'WO' || warData.status === 'Dodge') {
        console.log(`[DEBUG DODGE SUBMIT] Condi√ß√£o de dodge submiss√£o FALHOU: warData √© ${warData ? 'v√°lido' : 'nulo/indefinido'} ou status inv√°lido (status atual: ${warData ? warData.status : 'N/A'})`);
        return interaction.editReply({ content: '‚ùå Esta war j√° foi conclu√≠da ou n√£o pode ser declarada Dodge neste momento.', ephemeral: true });
    }
    console.log(`[DEBUG DODGE SUBMIT] Condi√ß√£o de dodge submiss√£o PASSOU.`);


    // L√≥gica de permiss√£o para SUBMETER DODGE
    const isModerator = (globalConfig.moderatorRoles || []).some(roleId => interaction.member.roles.cache.has(roleId));
    const isScoreOperator = (globalConfig.scoreOperatorRoles || []).some(roleId => interaction.member.roles.cache.has(roleId));

    if (!isModerator && !isScoreOperator) {
        console.log(`[DEBUG DODGE SUBMIT] Falha de permiss√£o para ${interaction.user.tag}.`);
        return interaction.editReply({ 
            content: '‚ùå Voc√™ n√£o tem permiss√£o para declarar Dodge. Apenas moderadores ou operadores de score.', 
            ephemeral: true 
        });
    }
    console.log(`[DEBUG DODGE SUBMIT] Permiss√µes VERIFICADAS para ${interaction.user.tag}.`);

    const dodgingGuildName = interaction.fields.getTextInputValue('dodging_guild_name');
    console.log(`[DEBUG DODGE SUBMIT] Guilda digitada para dodge: ${dodgingGuildName}`);

    let winnerGuildName;
    let dodgingGuildData;

    if (dodgingGuildName.toLowerCase() === warData.yourGuild.name.toLowerCase()) {
        dodgingGuildData = warData.yourGuild;
        winnerGuildName = warData.enemyGuild.name;
    } else if (dodgingGuildName.toLowerCase() === warData.enemyGuild.name.toLowerCase()) {
        dodgingGuildData = warData.enemyGuild;
        winnerGuildName = warData.yourGuild.name;
    } else {
        console.log(`[DEBUG DODGE SUBMIT] Nome da guilda de dodge inv√°lido.`);
        return interaction.editReply({ content: `‚ùå O nome da guilda "${dodgingGuildName}" n√£o corresponde a nenhuma guilda nesta war.` });
    }
    console.log(`[DEBUG DODGE SUBMIT] Guilda que deu dodge: ${dodgingGuildData.name}, Guilda vencedora: ${winnerGuildName}`);

    
    const dodgingGuildDB = await loadGuildByName(dodgingGuildData.name);
    const winnerGuildDB = await loadGuildByName(winnerGuildName);
    await processWarResultForPersonalScores(winnerGuildName, dodgingGuildData.name);

    if (dodgingGuildDB) {
        dodgingGuildDB.score.losses = (dodgingGuildDB.score?.losses || 0) + 1;
        dodgingGuildDB.updatedAt = new Date().toISOString(); 
        dodgingGuildDB.updatedBy = interaction.user.id;
        await saveGuildData(dodgingGuildDB);
        console.log(`[DEBUG DODGE SUBMIT] Score de ${dodgingGuildDB.name} atualizado (+1 derrota).`);
    }
    if (winnerGuildDB) {
        winnerGuildDB.score.wins = (winnerGuildDB.score?.wins || 0) + 1;
        winnerGuildDB.updatedAt = new Date().toISOString(); 
        winnerGuildDB.updatedBy = interaction.user.id;
        await saveGuildData(winnerGuildDB);
        console.log(`[DEBUG DODGE SUBMIT] Score de ${winnerGuildDB.name} atualizado (+1 vit√≥ria).`);
    }

    warData.status = 'Dodge'; 
    await saveWarTicket(warData);
    await deleteWarTicket(threadId); 
    console.log(`[DEBUG DODGE SUBMIT] warData salva como Dodge e ticket deletado do DB.`);


    client.emit('updateLeaderboard'); 

    let warEmbed = new EmbedBuilder(interaction.message.embeds[0].toJSON()); 
    warEmbed.fields = warEmbed.data.fields || []; 
    const statusFieldIndex = warEmbed.fields.findIndex(field => field.name === 'Status');
    if (statusFieldIndex !== -1) {
        warEmbed.spliceFields(statusFieldIndex, 1, { name: 'Status', value: `üèÉ Dodge - ${dodgingGuildName} Fugiu`, inline: false });
    } else {
        warEmbed.addFields({ name: 'Status', value: `üèÉ Dodge - ${dodgingGuildName} Fugiu`, inline: false });
    }
    warEmbed.setColor('#FF0000'); 
    warEmbed.addFields({ name: 'Resultado', value: `**${dodgingGuildName}** fugiu da War/Glad contra **${winnerGuildName}**.`, inline: false });

    await interaction.message.edit({ embeds: [warEmbed], components: [] }); 

    await interaction.channel.send(`**Aten√ß√£o!** A War/Glad entre **${warData.yourGuild.name}** e **${warData.enemyGuild.name}** foi declarada **DODGE**! **${dodgingGuildName}** fugiu!`);

    // C√ìDIGO CORRIGIDO PARA USAR DENTRO DE handleWarDodgeSelectGuildSubmit
    const dodgeLogChannel = await client.channels.fetch(globalConfig.dodgeLogChannelId).catch(() => null);
    if (dodgeLogChannel && dodgeLogChannel.type === ChannelType.GuildText && dodgeLogChannel.permissionsFor(client.user).has([PermissionFlagsBits.SendMessages, PermissionFlagsBits.EmbedLinks])) {
        const dodgeEmbed = new EmbedBuilder()
            .setTitle('üö® DODGE DETECTADO! üö®')
            .setColor('#FF0000')
            .setDescription(`Uma War/Glad foi declarada como **DODGE** no ticket: ${interaction.channel.url}`)
            .addFields(
                { name: 'Guilda que Deu Dodge', value: dodgingGuildName, inline: true },
                { name: 'Guilda Vencedora (sem dodge)', value: winnerGuildName, inline: true },
                { name: 'Thread da War', value: interaction.channel.url, inline: false },
                { name: 'Declarado por', value: interaction.user.tag, inline: true }
            )
            .setTimestamp();
        await dodgeLogChannel.send({ embeds: [dodgeEmbed] });
    } else {
        console.error(`‚ùå [DODGE LOG] Canal de log de dodge (ID: ${globalConfig.dodgeLogChannelId}) n√£o encontrado ou bot sem permiss√µes para enviar logs de dodge.`);
    }

    await sendLogMessage(
        client, globalConfig, interaction,
        'War Dodge Declarada',
        `Uma War/Glad foi declarada Dodge. **${dodgingGuildName}** fugiu contra **${winnerGuildName}**.`,
        [
            { name: 'Guilda que Deu Dodge', value: dodgingGuildName, inline: true },
            { name: 'Guilda Vencedora (sem dodge)', value: winnerGuildName, inline: true },
            { name: 'Thread da War', value: interaction.channel.url, inline: true },
        ]
    );
    
    // Restringir acesso e arquivar a thread
    await restrictThreadAccessOnCompletion(interaction, client, globalConfig, warData);a
    console.log(`[DEBUG DODGE SUBMIT] Dodge conclu√≠do com sucesso.`);
}


/**
 * Lida com os cliques nos bot√µes de pontua√ß√£o de round.
 * @param {ButtonInteraction} interaction - A intera√ß√£o do bot√£o.
 * @param {Client} client - A inst√¢ncia do bot.
 * @param {Object} globalConfig - A configura√ß√£o global do bot.
 */
async function handleWarRoundButton(interaction, client, globalConfig) {
    await interaction.deferUpdate();
    // O customId √©: war_round_win_{NOME_COM_UNDERSCORES}_{ROUND}
    const customIdParts = interaction.customId.split('_');
    const roundNumberStr = customIdParts.pop();

    const winningEntityIdForButton = customIdParts.slice(3).join('_');
    // Converte os underscores de volta para espa√ßos para a compara√ß√£o
    const winningEntityName = winningEntityIdForButton.replace(/_/g, ' ');

    const currentRoundClicked = parseInt(roundNumberStr);

    const threadId = interaction.channel.id;
    const warData = await loadWarTicketByThreadId(threadId);

    // --- Valida√ß√µes de Status e Round ---
    // (O resto da fun√ß√£o pode continuar como est√°, pois agora `winningEntityName` estar√° no formato correto)
    if (!warData || warData.status !== 'Aceita') {
        return interaction.followUp({ content: '...', ephemeral: true });
    }
    if (currentRoundClicked !== warData.currentRound) {
        return interaction.followUp({ content: `‚ùå Voc√™ s√≥ pode votar no Round ${warData.currentRound} agora.`, ephemeral: true });
    }

    // --- Verifica√ß√£o de Permiss√µes ---
    const isModerator = (globalConfig.moderatorRoles || []).some(roleId => interaction.member.roles.cache.has(roleId));
    const isScoreOperator = (globalConfig.scoreOperatorRoles || []).some(roleId => interaction.member.roles.cache.has(roleId));

    if (!isModerator && !isScoreOperator) {
        return interaction.followUp({ content: '‚ùå Apenas moderadores ou operadores de score podem registrar o resultado das rodadas.', ephemeral: true });
    }

    // --- L√≥gica do Round ---
    let losingEntityName;
    if (winningEntityName.toLowerCase() === warData.yourEntity.name.toLowerCase()) {
        losingEntityName = warData.enemyEntity.name;
    } else if (winningEntityName.toLowerCase() === warData.enemyEntity.name.toLowerCase()) {
        losingEntityName = warData.yourEntity.name;
    } else {
        return interaction.followUp({ content: '‚ùå Erro interno: Nome da entidade vencedora da rodada inv√°lido.', ephemeral: true });
    }

    // Atualiza o score do round
    warData.roundScores[winningEntityName]++;
    warData.currentRound++; // Avan√ßa para o pr√≥ximo round

    // --- Atualiza√ß√£o do Embed e Componentes ---
    const warEmbed = new EmbedBuilder(interaction.message.embeds[0].toJSON());
    warEmbed.fields = warData.fields || [];
    let components = [];

    const scoreFieldIndex = warEmbed.fields.findIndex(field => field.name === 'Score Atual');
    const newScoreValue = `${warData.yourEntity.name}: ${warData.roundScores[warData.yourEntity.name]} | ${warData.enemyEntity.name}: ${warData.roundScores[warData.enemyEntity.name]}`;
    if (scoreFieldIndex !== -1) {
        warEmbed.spliceFields(scoreFieldIndex, 1, { name: 'Score Atual', value: newScoreValue, inline: false });
    } else {
        warEmbed.addFields({ name: 'Score Atual', value: newScoreValue, inline: false });
    }

    let finalMessage = '';
    let winnerDeclared = false;

    // --- L√≥gica de Vit√≥ria (2 de 3 rounds) ---
    const yourScore = warData.roundScores[warData.yourEntity.name];
    const enemyScore = warData.roundScores[warData.enemyEntity.name];

    if (yourScore >= ROUNDS_TO_WIN || enemyScore >= ROUNDS_TO_WIN) {
        winnerDeclared = true;
        const finalWinner = yourScore >= ROUNDS_TO_WIN ? warData.yourEntity : warData.enemyEntity;
        const finalLoser = yourScore >= ROUNDS_TO_WIN ? warData.enemyEntity : warData.yourEntity;

        finalMessage = `üéâ Parab√©ns! **${finalWinner.name}** venceu a War/Glad contra **${finalLoser.name}** por ${yourScore}x${enemyScore}!`;
        warEmbed.addFields({ name: 'üèÜ Vencedor da War', value: `**${finalWinner.name}** (${finalWinner.type})`, inline: false });
        warEmbed.setColor('#2ECC71');

        const statusFieldIndex = warEmbed.fields.findIndex(field => field.name === 'Status');
        if (statusFieldIndex !== -1) {
            warEmbed.spliceFields(statusFieldIndex, 1, { name: 'Status', value: '‚úÖ Conclu√≠da', inline: false });
        } else {
            warEmbed.addFields({ name: 'Status', value: '‚úÖ Conclu√≠da', inline: false });
        }

        warData.status = 'Conclu√≠da';
        components = []; // Remove os bot√µes

        // --- ATUALIZA√á√ÉO GENERALIZADA DOS SCORES ---
        // Atualiza scores das entidades (time ou guilda)
        await saveEntityScore(finalWinner.name, finalWinner.type, { wins: 1, losses: 0 });
        await saveEntityScore(finalLoser.name, finalLoser.type, { wins: 0, losses: 1 });

        // Atualiza scores pessoais dos membros
        await processWarResultForPersonalScores(finalWinner, finalLoser);

        // Emite eventos para ambos os rankings
        client.emit('updateLeaderboard');
        client.emit('updateTeamLeaderboard'); // Adicionar este evento no seu index.js se n√£o existir

        await deleteWarTicket(warData.threadId);
        // ‚úÖ CORRE√á√ÉO AQUI: Passe 'interaction' como primeiro argumento
        await restrictThreadAccessOnCompletion(interaction, client, globalConfig, warData); 

    } else if (warData.currentRound <= MAX_ROUNDS) {
        // A war continua, cria bot√µes para o pr√≥ximo round
        components = createWarCurrentButtons(warData);
        const statusFieldIndex = warEmbed.fields.findIndex(field => field.name === 'Status');
        const newStatus = `Round ${warData.currentRound} - Em Andamento`;
        if (statusFieldIndex !== -1) {
            warEmbed.spliceFields(statusFieldIndex, 1, { name: 'Status', value: newStatus, inline: false });
        } else {
            warEmbed.addFields({ name: 'Status', value: newStatus, inline: false });
        }
    } else {
        // Empate ou sem vencedor
        finalMessage = `üö´ A War/Glad entre **${warData.yourEntity.name}** e **${warData.enemyEntity.name}** terminou sem um vencedor claro.`;
        warEmbed.setColor('#95A5A6');
        const statusFieldIndex = warEmbed.fields.findIndex(field => field.name === 'Status');
        if (statusFieldIndex !== -1) {
            warEmbed.spliceFields(statusFieldIndex, 1, { name: 'Status', value: 'üö´ Sem Vencedor Claro', inline: false });
        }
        warData.status = 'Conclu√≠da';
        components = [];
        await deleteWarTicket(warData.threadId);
        await restrictThreadAccessOnCompletion(interaction, client, globalConfig, warData);
    }

    // Salva o estado atualizado da war
    await saveWarTicket(warData);

    // Edita a mensagem do embed na thread
    await interaction.message.edit({ embeds: [warEmbed], components: components });

    // Enviar log da a√ß√£o de round
    const logFields = [
        { name: `Vencedor do Round ${currentRoundClicked}`, value: winningEntityName, inline: true },
        { name: 'Score Atual', value: newScoreValue, inline: true },
        { name: 'Status da War', value: warData.status, inline: true },
        { name: 'Thread', value: interaction.channel.url, inline: false },
    ];
    if (winnerDeclared) {
        logFields.push({ name: 'Vencedor Final Declarado', value: yourScore >= ROUNDS_TO_WIN ? warData.yourEntity.name : warData.enemyEntity.name, inline: false });
    }
    await sendLogMessage(
        client, globalConfig, interaction,
        'Resultado de Round de War',
        `Resultado do Round ${currentRoundClicked} da war entre **${warData.yourEntity.name}** e **${warData.enemyEntity.name}** foi registrado.`,
        logFields
    );

    if (finalMessage) {
        await interaction.channel.send(finalMessage);
    }
    console.log(`[DEBUG ROUND] A√ß√£o de round ${currentRoundClicked} conclu√≠da com sucesso.`);
}

module.exports = {
    handleWarAcceptButton,
    handleWarRequestDodgeButton,
    handleWarDodgeSelectGuildSubmit,
    handleWarRoundButton,
};
